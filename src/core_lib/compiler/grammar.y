/*
    This file is a part of Tiny-Shading-Language or TSL, an open-source cross
    platform programming shading language.

    Copyright (c) 2020-2020 by Jiayin Cao - All rights reserved.

    TSL is a free software written for educational purpose. Anyone can distribute
    or modify it under the the terms of the GNU General Public License Version 3 as
    published by the Free Software Foundation. However, there is NO warranty that
    all components are functional in a perfect manner. Without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License along with
    this program. If not, see <http://www.gnu.org/licenses/gpl-3.0.html>.
 */

%{
/*
    --------------------------------------------------------------------
    WARNING:
            This file is automatically generated, do not modify.
    --------------------------------------------------------------------
*/
	#include <string>
	#include "tslversion.h"
	#include "compiler/ast.h"
	#include "compiler/types.h"
	#include "compiler/compiler_impl.h"

	USE_TSL_NAMESPACE

	#define scanner tsl_compiler->get_scanner()

	int yylex( union YYSTYPE *,struct YYLTYPE *,void * );
    void yyerror(struct YYLTYPE* loc, void *tsl_compiler, char const *str);
	int g_verbose = 0;	// somehow bool is not working here.
%}

/* definitions of tokens and types passed by FLEX */
%union {
    class AstNode 					*p;	/* pointers for the AST struct nodes */
	float							f; /* floating point value cache. */
	int								i; /* integer value or enum values. */
	const char						*s;	/* string values. */
	char							c; /* single char. */
	Tsl_Namespace::DataType			t;	/* data type. */
	Tsl_Namespace::VariableConfig	vc; /* 'out', 'in' */
}

%locations
%define api.pure
%lex-param {void * scanner}
%parse-param {class Tsl_Namespace::TslCompiler_Impl * tsl_compiler}

%token <s> ID
%token <i> INT_NUM
%token <f> FLT_NUM
%token INC_OP			"++"
%token DEC_OP			"--"
%token <vc> OUT			"out"
%token <vc> IN			"in"
%token <vc> CONST		"const"
%token SHADER_FUNC_ID
%token <i> TYPE_INT	    "int"
%token <i> TYPE_FLOAT	"float"
%token <i> TYPE_DOUBLE  "double"
%token <i> TYPE_MATRIX  "matrix"
%token <i> TYPE_FLOAT3  "float3"
%token <i> TYPE_BOOL	"bool"
%token TYPE_VOID		"void"
%token EOL              ";"
%token L_CBRACKET       "{"
%token R_CBRACKET       "}"
%token L_RBRACKET       "("
%token R_RBRACKET       ")"
%token L_SBRACKET       "["
%token R_SBRACKET       "]"
%token OP_ADD           "+"
%token OP_MINUS         "-"
%token OP_MULT          "*"
%token OP_DIV           "/"
%token OP_MOD			"%"
%token OP_AND			"&"
%token OP_OR			"|"
%token OP_XOR			"^"
%token OP_LOGIC_AND     "&&"
%token OP_LOGIC_OR		"||"
%token OP_EQ			"=="
%token OP_NE			"!="
%token OP_GE			">="
%token OP_G				">"
%token OP_LE			"<="
%token OP_L				"<"
%token OP_SHL			"<<"
%token OP_SHR			">>"
%token OP_ADD_ASSIGN    "+="
%token OP_MINUS_ASSIGN  "-="
%token OP_MULT_ASSIGN   "*="
%token OP_DIV_ASSIGN    "/="
%token OP_MOD_ASSIGN    "%="
%token OP_ASSIGN        "="
%token OP_AND_ASSIGN	"&="
%token OP_OR_ASSIGN		"|="
%token OP_XOR_ASSIGN	"^="
%token OP_SHL_ASSIGN	"<<="
%token OP_SHR_ASSIGN	">>="
%token OP_NOT			"!"
%token OP_COMP			"~"
%token DOT				"."
%token COMMA            ","
%token COLON            ":"
%token METADATA_START   "<<<"
%token METADATA_END     ">>>"
%token RETURN		    "return"
%token QUESTION_MARK	"?"
%token IF				"if"
%token ELSE				"else"
%token FOR				"for"
%token WHILE			"while"
%token DO				"do"
%token TRUE             "true"
%token FALSE            "false"
%token BREAK            "break"
%token CONTINUE         "continue"
%token CLOSURE          "closure"
%token MAKE_CLOSURE     "make_closure"

%type <p> PROGRAM FUNCTION_ARGUMENT_DECL FUNCTION_ARGUMENT_DECLS SHADER_FUNCTION_ARGUMENT_DECLS FUNCTION_BODY VARIABLE_LVALUE ID_OR_FIELD FUNCTION_ARGUMENTS SHADER_FUNCTION_ARGUMENT_DECL FOR_INIT_STATEMENT
%type <p> STATEMENT STATEMENTS STATEMENT_RETURN STATEMENT_EXPRESSION_OPT STATEMENT_COMPOUND_EXPRESSION STATEMENT_VARIABLES_DECLARATIONS VARIABLE_DECLARATION VARIABLE_DECLARATIONS STATEMENT_CONDITIONAL STATEMENT_LOOP STATEMENT_SCOPED STATEMENT_LOOPMOD
%type <p> EXPRESSION_COMPOUND EXPRESSION_CONST EXPRESSION_BINARY EXPRESSION EXPRESSION_VARIABLE EXPRESSION_FUNCTION_CALL EXPRESSION_TERNARY EXPRESSION_COMPOUND_OPT EXPRESSION_SCOPED EXPRESSION_ASSIGN EXPRESSION_UNARY EXPRESSION_TYPECAST EXPRESSION_MAKE_CLOSURE
%type <c> OP_UNARY
%type <t> TYPE
%type <i> REC_OR_DEC
%type <vc> ARGUMENT_CONFIG ARGUMENT_CONFIGS_OPT ARGUMENT_CONFIGS

%nonassoc IF_THEN
%nonassoc ELSE

%left ","
%right "=" "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" "&=" "|=" "^="
%right "?" ":"
%left "||"
%left "&&"
%left "|"
%left "^"
%left "&"
%left "==" "!="
%left ">" ">=" "<" "<=" 
%left "<<" ">>"
%left "+" "-"
%left "*" "/" "%"
%right UMINUS_PREC "!" "~"
%left "++" "--"
%left "(" ")"
%left "[" "]"
%left "<<<" ">>>"

/* the start token */
%start PROGRAM

%%
// A programm has a bunch of global statement.
PROGRAM:
	// empty shader
	{
        $$ = nullptr;
	}
	|
	GLOBAL_STATEMENTS {
	};

// One or multiple of blobal statements
GLOBAL_STATEMENTS:
	GLOBAL_STATEMENT{
	}
	|
	GLOBAL_STATEMENT GLOBAL_STATEMENTS {
	};

// Global statement could be one of the followings
//  - Global variable decleration.
//  - Global function definition.
//  - Global data structure definition.
//  - Shader function definition.
GLOBAL_STATEMENT:
	STATEMENT_VARIABLES_DECLARATIONS{
	}
	|
    SHADER_DEF {
    }
	|
	FUNCTION_DEF {
	};

// Shader is the only unit that can be exposed in the group.
SHADER_DEF:
	SHADER_FUNC_ID ID "(" SHADER_FUNCTION_ARGUMENT_DECLS ")" FUNCTION_BODY {
		AstNode_FunctionBody*		body = AstNode::castType<AstNode_FunctionBody>($6);
		AstNode_VariableDecl*		variables = AstNode::castType<AstNode_VariableDecl>($4);
		AstNode_FunctionPrototype*	function = new AstNode_FunctionPrototype($2, variables, body, true);
		tsl_compiler->push_function(function, true);
	};

SHADER_FUNCTION_ARGUMENT_DECLS:
	/* empty */
	{
		$$ = nullptr;
	}
	|
	SHADER_FUNCTION_ARGUMENT_DECL{
	}
	|
	SHADER_FUNCTION_ARGUMENT_DECL "," SHADER_FUNCTION_ARGUMENT_DECLS {
		AstNode* node_arg = $1;
		AstNode* node_args = $3;
		if(!node_arg)
			$$ = node_args;
		else
			$$ = node_arg->append( node_args );
	};

SHADER_FUNCTION_ARGUMENT_DECL:
	FUNCTION_ARGUMENT_DECL ARGUMENT_METADATA {
	};

ARGUMENT_METADATA:
	// no meta data
	{}
	|
	"<<<" ">>>"{
	};

// Standard function definition
FUNCTION_DEF:
	TYPE ID "(" FUNCTION_ARGUMENT_DECLS ")" FUNCTION_BODY {
		AstNode_FunctionBody*		body = AstNode::castType<AstNode_FunctionBody>($6);
		AstNode_VariableDecl*		variables = AstNode::castType<AstNode_VariableDecl>($4);
		AstNode_FunctionPrototype*	function = new AstNode_FunctionPrototype($2, variables, body, false, $1);

        tsl_compiler->push_function(function);
	};

FUNCTION_ARGUMENT_DECLS:
	/* empty */
	{
		$$ = nullptr;
	}
	|
	FUNCTION_ARGUMENT_DECL
	{
		$$ = $1;
	}
	|
	FUNCTION_ARGUMENT_DECL "," FUNCTION_ARGUMENT_DECLS{
		AstNode* node_arg = $1;
		AstNode* node_args = $3;
		$$ = node_arg->append( node_args );
	};

FUNCTION_ARGUMENT_DECL:
	ARGUMENT_CONFIGS_OPT TYPE ID {
		VariableConfig config = $1;
		AstNode_SingleVariableDecl* node = new AstNode_SingleVariableDecl($3, $2, config);
		$$ = node;
	}
	|
	ARGUMENT_CONFIGS_OPT TYPE ID "=" EXPRESSION {
		VariableConfig config = $1;
		AstNode_Expression* init_exp = AstNode::castType<AstNode_Expression>($5);
		AstNode_SingleVariableDecl* node = new AstNode_SingleVariableDecl($3, $2, config, init_exp);
		$$ = node;
	};

ARGUMENT_CONFIGS_OPT:
	/* empty */
	{
		$$ = VariableConfig::NONE;
	}
	|
	ARGUMENT_CONFIGS
	{
		$$ = $1;
	};

ARGUMENT_CONFIGS:
	ARGUMENT_CONFIG
	{
		$$ = $1;
	}
	|
	ARGUMENT_CONFIG ARGUMENT_CONFIGS
	{
		int config0 = $1;
		int config1 = $2;
		$$ = VariableConfig( config0 | config1 );
	};

ARGUMENT_CONFIG:
	"in"
	{
		$$ = VariableConfig::INPUT;
	}
	|
	"out"
	{
		$$ = VariableConfig::OUTPUT;
	}
	|
	"const"
	{
		$$ = VariableConfig::CONST;
	};

FUNCTION_BODY:
	"{" STATEMENTS "}" {
		AstNode_Statement*	statements = AstNode::castType<AstNode_Statement>($2);
		$$ = new AstNode_FunctionBody(statements);
	}
    |
    ";"
    {
        $$ = nullptr;
    };

STATEMENTS:
	STATEMENTS STATEMENT{
		AstNode_Statement* statements = AstNode::castType<AstNode_Statement>$1;
		AstNode_Statement* statement = AstNode::castType<AstNode_Statement>$2;
		if(!statements)
			$$ = statement;
		else if(!statement)
			$$ = statements;
        else{
            if( auto compound_statement = AstNode::castType<AstNode_CompoundStatements>(statements, false) ){
                compound_statement->append_statement(statement);
                $$ = statements;
            }else{
                AstNode_CompoundStatements* ret = new AstNode_CompoundStatements();
                ret->append_statement(statements);
                ret->append_statement(statement);
                $$ = ret;
            }
        }
	}
	|
	/* empty */ {
		$$ = nullptr;
	};

STATEMENT:
	STATEMENT_SCOPED
	|
	STATEMENT_RETURN
    |
    STATEMENT_LOOPMOD
	|
	STATEMENT_VARIABLES_DECLARATIONS
	|
	STATEMENT_CONDITIONAL
	|
	STATEMENT_LOOP
	|
	STATEMENT_COMPOUND_EXPRESSION;

STATEMENT_LOOPMOD:
    "break" ";"
    {
        $$ = new AstNode_Statement_Break ();
    }
    | 
    "continue" ";"
    {
        $$ = new AstNode_Statement_Continue ();
    }
    ;
    
STATEMENT_SCOPED:
	"{" STATEMENTS "}"
	{
        AstNode_Statement* statement = AstNode::castType<AstNode_Statement>($2);
        $$ = new AstNode_ScoppedStatement(statement);
	}
	;

STATEMENT_RETURN:
	"return" STATEMENT_EXPRESSION_OPT ";"
	{
		AstNode_Expression* expression = AstNode::castType<AstNode_Expression>($2);
		$$ = new AstNode_Statement_Return(expression);
	};

STATEMENT_EXPRESSION_OPT:
	EXPRESSION_COMPOUND {
	}
	|
	/* empty */ {
		$$ = nullptr;
	};

STATEMENT_VARIABLES_DECLARATIONS:
	TYPE VARIABLE_DECLARATIONS ";"
	{
		AstNode_VariableDecl* vars = AstNode::castType<AstNode_VariableDecl>($2);
		$$ = new AstNode_Statement_VariableDecls(vars);
	};

VARIABLE_DECLARATIONS:
	VARIABLE_DECLARATION
	|
	VARIABLE_DECLARATION "," VARIABLE_DECLARATIONS {
		AstNode* variable = $1;
		AstNode* variables = $3;
		$$ = variable->append( variables );
	};

VARIABLE_DECLARATION:
	ID {
		const DataType type = tsl_compiler->data_type_cache();
		AstNode_SingleVariableDecl* node = new AstNode_SingleVariableDecl($1, type);
		$$ = node;
	}
    |
    ID "[" EXPRESSION "]" {
        const DataType type = tsl_compiler->data_type_cache();
        AstNode_Expression* cnt = AstNode::castType<AstNode_Expression>($3);
		AstNode_ArrayDecl* node = new AstNode_ArrayDecl($1, type, cnt);
		$$ = node;
    }
	|
	ID "=" EXPRESSION {
		// initialization is not correctly handled yet.
		const DataType type = tsl_compiler->data_type_cache();
		AstNode_Expression* init_exp = AstNode::castType<AstNode_Expression>($3);
		AstNode_SingleVariableDecl* node = new AstNode_SingleVariableDecl($1, type, VariableConfig::NONE, init_exp);
		$$ = node;
	};

STATEMENT_CONDITIONAL:
	"if" "(" EXPRESSION_COMPOUND ")" STATEMENT %prec IF_THEN {
		AstNode_Expression* cond = AstNode::castType<AstNode_Expression>($3);
		AstNode_Statement*	true_statements = AstNode::castType<AstNode_Statement>($5);
		$$ = new AstNode_Statement_Condition( cond , true_statements );
	}
	|
	"if" "(" EXPRESSION_COMPOUND ")" STATEMENT "else" STATEMENT {
		AstNode_Expression* cond = AstNode::castType<AstNode_Expression>($3);
		AstNode_Statement*	true_statements = AstNode::castType<AstNode_Statement>($5);
		AstNode_Statement*	false_statements = AstNode::castType<AstNode_Statement>($7);
		$$ = new AstNode_Statement_Condition( cond, true_statements, false_statements );
	};
	
STATEMENT_LOOP:
	"while" "(" EXPRESSION_COMPOUND ")" STATEMENT{
		AstNode_Expression* cond = AstNode::castType<AstNode_Expression>($3);
		AstNode_Statement*	statements = AstNode::castType<AstNode_Statement>($5);
		$$ = new AstNode_Statement_Loop_While( cond , statements );
	}
	|
	"do" STATEMENT "while" "(" EXPRESSION_COMPOUND ")" ";"{
		AstNode_Expression* cond = AstNode::castType<AstNode_Expression>($5);
		AstNode_Statement*	statements = AstNode::castType<AstNode_Statement>($2);
		$$ = new AstNode_Statement_Loop_DoWhile( cond , statements );
	}
	|
	"for" "(" FOR_INIT_STATEMENT EXPRESSION_COMPOUND_OPT ";" EXPRESSION_COMPOUND_OPT ")" STATEMENT {
        AstNode_Statement*  init = AstNode::castType<AstNode_Statement>($3);
        AstNode_Expression* cond = AstNode::castType<AstNode_Expression>($4);
        AstNode_Expression* iter = AstNode::castType<AstNode_Expression>($6);
		AstNode_Statement*	statements = AstNode::castType<AstNode_Statement>($8);
		$$ = new AstNode_Statement_Loop_For(init, cond, iter, statements);
	};
	
FOR_INIT_STATEMENT:
	";"{
        $$ = nullptr;
	}
	|
	STATEMENT_COMPOUND_EXPRESSION{
	}
	|
	STATEMENT_VARIABLES_DECLARATIONS {
	};
	
STATEMENT_COMPOUND_EXPRESSION:
	EXPRESSION_COMPOUND ";" {
		AstNode_Expression* expression = AstNode::castType<AstNode_Expression>($1);
		$$ = new AstNode_Statement_CompoundExpression(expression);
	}

EXPRESSION_COMPOUND_OPT:
	/* empty */ 
	{
		$$ = nullptr;
	}
	|
	EXPRESSION_COMPOUND;

EXPRESSION_COMPOUND:
	EXPRESSION
    /*
    Comma operator provides very little value to the language, it is not supported for simplicity for now.
	| 
	EXPRESSION "," EXPRESSION_COMPOUND {
		AstNode* exp = $1;
		AstNode* extra_exp = $3;
		$$ = exp->append( extra_exp );
	}
    */
    ;

// Exrpession always carries a value so that it can be used as input for anything needs a value,
// like if condition, function parameter, etc.
EXPRESSION:
	EXPRESSION_UNARY
	|
	EXPRESSION_BINARY
	|
	EXPRESSION_TERNARY
	|
	EXPRESSION_ASSIGN
	|
	EXPRESSION_FUNCTION_CALL
	|
	EXPRESSION_CONST
	|
	EXPRESSION_SCOPED
	|
	EXPRESSION_TYPECAST
	|
	EXPRESSION_VARIABLE
    |
    EXPRESSION_MAKE_CLOSURE
    {
	};

EXPRESSION_UNARY:
	OP_UNARY EXPRESSION %prec UMINUS_PREC {
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($2);
		switch( $1 ){
			case '+':
				$$ = new AstNode_Unary_Pos(exp);	// it is still necessary to wrap something here to prevent this value from being a lvalue later.
				break;
			case '-':
				$$ = new AstNode_Unary_Neg(exp);
				break;
			case '!':
				$$ = new AstNode_Unary_Not(exp);
				break;
			case '~':
				$$ = new AstNode_Unary_Compl(exp);
				break;
			default:
				$$ = nullptr;
		}
	};
	
OP_UNARY:
	"-" {
		$$ = '-';
	}
	|
	"+" {
		$$ = '+';
	}
	|
	"!" {
		$$ = '!';
	}
	|
	"~" {
		$$ = '~';
	};

EXPRESSION_BINARY:
	EXPRESSION "&&" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_And( left , right );
	}
	|
	EXPRESSION "||" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Or( left , right );
	}
	|
	EXPRESSION "&" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Bit_And( left , right );
	}
	|
	EXPRESSION "|" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Bit_Or( left , right );
	}
	|
	EXPRESSION "^" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Bit_Xor( left , right );
	}
	|
	EXPRESSION "==" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Eq( left , right );
	}
	|
	EXPRESSION "!=" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Ne( left , right );
	}
	|
	EXPRESSION ">" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_G( left , right );
	}
	|
	EXPRESSION "<" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_L( left , right );
	}
	|
	EXPRESSION ">=" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Ge( left , right );
	}
	|
	EXPRESSION "<=" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Le( left , right );
	}
	|
	EXPRESSION "<<" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Shl( left , right );
	}
	|
	EXPRESSION ">>" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Shr( left , right );
	}
	|
	EXPRESSION "+" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Add( left , right );
	}
	|
	EXPRESSION "-" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Minus( left , right );
	}
	|
	EXPRESSION "*" EXPRESSION {
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Multi( left , right );
	}
	|
	EXPRESSION "/" EXPRESSION{
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Div( left , right );
	}
	|
	EXPRESSION "%" EXPRESSION{
		AstNode_Expression* left = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* right = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_Binary_Mod( left , right );
	};

// Ternary operation support
EXPRESSION_TERNARY:
	EXPRESSION "?" EXPRESSION ":" EXPRESSION {
		AstNode_Expression* cond = AstNode::castType<AstNode_Expression>($1);
		AstNode_Expression* true_expr = AstNode::castType<AstNode_Expression>($3);
		AstNode_Expression* false_expr = AstNode::castType<AstNode_Expression>($5);
		$$ = new AstNode_Ternary( cond , true_expr , false_expr );
	};

// Assign an expression to a reference
EXPRESSION_ASSIGN:
	VARIABLE_LVALUE "=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode* p = $3;
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_Eq( var , exp );
	}
	|
	VARIABLE_LVALUE "+=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_AddEq( var , exp );
	}
	|
	VARIABLE_LVALUE "-=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_MinusEq( var , exp );
	}
	|
	VARIABLE_LVALUE "*=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_MultiEq( var , exp );
	}
	|
	VARIABLE_LVALUE "/=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_DivEq( var , exp );
	}
	|
	VARIABLE_LVALUE "%=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_ModEq( var , exp );
	}
	|
	VARIABLE_LVALUE "&=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_AndEq( var , exp );
	}
	|
	VARIABLE_LVALUE "|=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_OrEq( var , exp );
	}
	|
	VARIABLE_LVALUE "^=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_XorEq( var , exp );
	}
	|
	VARIABLE_LVALUE "<<=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_ShlEq( var , exp );
	}
	|
	VARIABLE_LVALUE ">>=" EXPRESSION {
		AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_ExpAssign_ShrEq( var , exp );
	};

// Function call, this is only non-shader function. TSL doesn't allow calling shader function.
EXPRESSION_FUNCTION_CALL:
	ID "(" FUNCTION_ARGUMENTS ")" {
		AstNode_Expression* args = AstNode::castType<AstNode_Expression>($3);
		$$ = new AstNode_FunctionCall( $1 , args );
	};

// a special function just for creating closure data structure.
EXPRESSION_MAKE_CLOSURE:
    "make_closure" "<" ID ">" "(" FUNCTION_ARGUMENTS ")"
    {
        AstNode_Expression* args = AstNode::castType<AstNode_Expression>($6);
		$$ = new AstNode_Expression_MakeClosure( $3 , args );
    };

// None-shader function arguments
FUNCTION_ARGUMENTS:
	{
		$$ = nullptr;
	}
	|
	EXPRESSION
	|
	EXPRESSION "," FUNCTION_ARGUMENTS {
		AstNode* node_arg = $1;
		AstNode* node_args = $3;
		$$ = node_arg->append( node_args );
	};


// Const literal
EXPRESSION_CONST:
	INT_NUM {
		$$ = new AstNode_Literal_Int( $1 );
	}
	|
	FLT_NUM {
		$$ = new AstNode_Literal_Flt( $1 );
	}
    |
    "true" {
        $$ = new AstNode_Literal_Bool( true );
    }
    |
    "false" {
        $$ = new AstNode_Literal_Bool( false );
    };

// Scopped expression
EXPRESSION_SCOPED:
	"(" EXPRESSION_COMPOUND ")" {
		$$ = $2;
	};

// This is for type casting
EXPRESSION_TYPECAST:
	"(" TYPE ")" EXPRESSION {
		const DataType type = $2;
		AstNode_Expression* exp = AstNode::castType<AstNode_Expression>($4);
		$$ = new AstNode_TypeCast(exp, type);
	};

EXPRESSION_VARIABLE:
	VARIABLE_LVALUE{
		$$ = $1;
	}
	|
	VARIABLE_LVALUE REC_OR_DEC {
		AstNode_Lvalue* exp = AstNode::castType<AstNode_Lvalue>($1);
		if( $2 == 1 )
			$$ = new AstNode_Expression_PostInc(exp);
		else if( $2 == 2 )
			$$ = new AstNode_Expression_PostDec(exp);
		else{
			// this should not happen
			$$ = exp;
		}
	}
	|
	REC_OR_DEC VARIABLE_LVALUE {
		AstNode_Lvalue* exp = AstNode::castType<AstNode_Lvalue>($2);
		if( $1 == 1 )
			$$ = new AstNode_Expression_PreInc(exp);
		else if( $1 == 2 )
			$$ = new AstNode_Expression_PreDec(exp);
		else{
			// this should not happen
			$$ = exp;
		}
	};

REC_OR_DEC:
	"++" {
		$$ = 1;
	}
	|
	"--" {
		$$ = 2;
	};

// No up to two dimensional array supported for now.
VARIABLE_LVALUE:
	ID_OR_FIELD;

ID_OR_FIELD:
	ID{
		$$ = new AstNode_VariableRef($1);
	}
    |
    VARIABLE_LVALUE "[" EXPRESSION "]"{
        AstNode_Lvalue* var = AstNode::castType<AstNode_Lvalue>($1);
        AstNode_Expression* index = AstNode::castType<AstNode_Expression>($3);
        $$ = new AstNode_ArrayAccess(var, index);
    }
	|
	VARIABLE_LVALUE "." ID {
	};

TYPE:
	"int" {
		$$ = DataType::INT;
		tsl_compiler->cache_next_data_type($$);
	}
	|
	"float" {
		$$ = DataType::FLOAT;
		tsl_compiler->cache_next_data_type($$);
	}
    |
    "double" {
        $$ = DataType::DOUBLE;
        tsl_compiler->cache_next_data_type($$);
    }
	|
	"matrix" {
		$$ = DataType::MATRIX;
		tsl_compiler->cache_next_data_type($$);
	}
	|
	"float3" {
		$$ = DataType::FLOAT3;
		tsl_compiler->cache_next_data_type($$);
	}
	|
	"bool" {
		$$ = DataType::BOOL;
		tsl_compiler->cache_next_data_type($$);
	}
	|
	"void" {
		$$ = DataType::VOID;
		tsl_compiler->cache_next_data_type($$);
	}
    |
    "closure" {
        $$ = DataType::CLOSURE;
		tsl_compiler->cache_next_data_type($$);
    }
    ;
%%

void yyerror(struct YYLTYPE* loc, void* x, char const * str){
	if(!g_verbose)
		return;

	// line number is incorrect for now
	printf( "line(%d, %d), error: %s\n", loc->first_line, loc->first_column, str);
}

void makeVerbose(int verbose){
	 g_verbose = verbose;
}
